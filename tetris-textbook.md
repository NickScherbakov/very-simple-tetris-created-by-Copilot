# Учебник: Создание игры Тетрис с Microsoft Copilot

## Введение

Этот учебник демонстрирует, как начинающий программист в сотрудничестве с Microsoft Copilot может создать классическую игру Тетрис. Этот проект — прекрасный пример того, как искусственный интеллект может помочь в процессе обучения программированию и разработке функциональных приложений.

## Содержание

1. [Подготовка к работе](#подготовка-к-работе)
2. [Разработка базовой структуры HTML](#разработка-базовой-структуры-html)
3. [Создание игровой логики на JavaScript](#создание-игровой-логики-на-javascript)
4. [Стилизация игры с помощью CSS](#стилизация-игры-с-помощью-css)
5. [Тестирование и отладка](#тестирование-и-отладка)
6. [Публикация проекта на GitHub](#публикация-проекта-на-github)
7. [Добавление адаптивного ИИ](#добавление-адаптивного-ии)
8. [Дальнейшее развитие проекта](#дальнейшее-развитие-проекта)

## Подготовка к работе

### Что нам понадобилось для начала работы:

1. **Базовые знания HTML, CSS и JavaScript** — даже минимальное понимание этих технологий позволило нам эффективно взаимодействовать с AI-ассистентом.
2. **Текстовый редактор** — в нашем случае использовался редактор с поддержкой Copilot.
3. **Подключение к интернету** — для взаимодействия с AI и поиска дополнительной информации.
4. **Git и GitHub** — для версионирования и публикации проекта.

### Первые шаги

Мы начали с обсуждения общей структуры проекта. Microsoft Copilot помог спланировать архитектуру игры, определить основные компоненты и предложил пошаговый план разработки. Это позволило сразу получить чёткое представление о будущем проекте.

## Разработка базовой структуры HTML

Мы создали файл `index.html` с базовой структурой:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Very Simple Tetris</title>
    <style>
        /* Здесь размещены стили игры */
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="tetris" width="240" height="400"></canvas>
        <div class="game-info">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="level">Level: <span id="level">1</span></div>
            <div class="lines">Lines: <span id="lines">0</span></div>
            <div class="next-piece">
                <p>Next:</p>
                <canvas id="next" width="80" height="80"></canvas>
            </div>
            <button id="start-button">Start / Pause</button>
        </div>
    </div>
    <script src="tetris.js"></script>
</body>
</html>
```

Copilot объяснил каждый элемент страницы и его назначение:
- Canvas для отрисовки игрового поля
- Информационная панель со счетом, уровнем и количеством линий
- Предварительный просмотр следующей фигуры
- Кнопка старта/паузы

## Создание игровой логики на JavaScript

Самая сложная часть проекта — игровая логика — была реализована в файле `tetris.js`. Microsoft Copilot помог разбить эту задачу на несколько подзадач:

1. **Создание основных констант и переменных** — определение размеров игрового поля, цветов фигур и т.д.

2. **Определение фигур Тетриса** — создание массивов, описывающих все семь классических фигур Тетриса с их возможными положениями при вращении.

3. **Инициализация игры** — настройка canvas, создание игрового цикла, обработка нажатий клавиш.

4. **Основная игровая механика**:
   - Отрисовка игрового поля
   - Создание новых фигур
   - Проверка столкновений
   - Перемещение и вращение фигур
   - Удаление заполненных линий
   - Подсчёт очков
   - Повышение уровня сложности

Вот фрагмент кода, иллюстрирующий определение фигур:

```javascript
const SHAPES = [
    // I-фигура
    [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ],
    // J-фигура
    [
        [2, 0, 0],
        [2, 2, 2],
        [0, 0, 0]
    ],
    // ...другие фигуры
];
```

Copilot объяснил логику каждой части кода, помог оптимизировать алгоритмы и предложил добавить дополнительные функции, такие как предпросмотр следующей фигуры и сохранение рекордов.

## Стилизация игры с помощью CSS

После создания функциональной части игры мы улучшили внешний вид с помощью CSS:

```css
body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    background-color: #f0f0f0;
    margin-top: 20px;
}

.game-container {
    display: flex;
    gap: 20px;
}

canvas {
    border: 1px solid #000;
    background-color: #000;
}

.game-info {
    width: 150px;
    padding: 10px;
    background-color: #eee;
    border: 1px solid #ccc;
    border-radius: 5px;
}

/* ...дополнительные стили... */
```

Microsoft Copilot предложил несколько вариантов оформления, помог адаптировать интерфейс для разных размеров экрана и добавил анимации для улучшения пользовательского опыта.

## Тестирование и отладка

После завершения разработки мы протестировали игру и устранили ошибки. Copilot помог:

1. Идентифицировать проблемные места в коде
2. Предложить решения для исправления багов
3. Оптимизировать производительность игры
4. Добавить обработку краевых случаев

Например, мы столкнулись с проблемой, когда фигуры иногда могли выходить за границы поля. Copilot помог реализовать функцию проверки границ:

```javascript
function isValidMove(matrix, cellRow, cellCol) {
    for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix[row].length; col++) {
            if (matrix[row][col] && (
                cellCol + col < 0 ||
                cellCol + col >= COLS ||
                cellRow + row >= ROWS ||
                board[cellRow + row][cellCol + col]
            )) {
                return false;
            }
        }
    }
    return true;
}
```

## Публикация проекта на GitHub

Финальным этапом нашего проекта стала публикация игры на GitHub. Microsoft Copilot помог:

1. Создать файлы README на нескольких языках с описанием проекта
2. Написать скрипт `upload_to_github.ps1` для автоматизации процесса публикации
3. Настроить Git для корректного версионирования нашего кода

Скрипт выполнил все необходимые действия: инициализировал Git-репозиторий, создал первый коммит и отправил код на GitHub.

## Добавление адаптивного ИИ

После того как базовая механика была готова, мы внедрили самобучающийся генератор фигур, анализирующий ошибки игрока. Copilot предложил разбить задачу на пять шагов:

1. **Расширяем интерфейс** — в `index.html` под блоком со счётом мы добавили панель «AI Insight» (обычный `<div>` с текстовым узлом `<p id="ai-summary">`), а также вынесли кнопку рекорда и сенсорные кнопки для мобильных устройств. Так игрок сразу видит, как ИИ реагирует на его действия.

2. **Подготавливаем ссылки и ключи хранения** — в верхней части `tetris.js` мы получили новый элемент (`const aiSummaryElement = document.getElementById('ai-summary');`) и добавили в `STORAGE_KEYS` идентификатор `tetrisAiStateV1`, чтобы сохранять веса алгоритма между сессиями вместе с рекордом и настройкой сетки.

3. **Измеряем состояние поля** — была создана утилита `computeBoardMetrics(boardState)`, которая для каждой колонки считает высоту, количество «дыр», суммарную высоту и показатель неровности. Пример функции:

```javascript
function computeBoardMetrics(boardState) {
    const heights = Array(COLS).fill(0);
    const holes = Array(COLS).fill(0);
    // проходим каждую колонку сверху вниз, фиксируем первую заполненную клетку и пустоты под ней
    return { heights, holes, totalHoles, maxHeight, aggregateHeight, bumpiness };
}
```

4. **Создаём тренер** — основная логика вынесена в `createAdaptiveEngine()`. Объект хранит веса для каждой фигуры, учитывает сколько «дыр» возникло из-за конкретного тетромино и предоставляет методы `loadFromStorage`, `resetForNewGame`, `selectShapeIndex`, `registerPlacement`, `getLiveHint`, `getSummary`.

```javascript
const aiTrainer = createAdaptiveEngine();

function createAdaptiveEngine() {
    const weights = Array(SHAPES.length).fill(1);
    let sessionHolesByShape = Array(SHAPES.length).fill(0);

    function selectShapeIndex() {
        const total = weights.reduce((sum, value) => sum + value, 0);
        let threshold = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
            threshold -= weights[i];
            if (threshold <= 0) return i;
        }
        return weights.length - 1;
    }

    function registerPlacement(shapeIndex, beforeMetrics, afterMetrics, linesCleared) {
        const holesDelta = afterMetrics.totalHoles - beforeMetrics.totalHoles;
        if (holesDelta > 0) {
            weights[shapeIndex] = Math.min(8, weights[shapeIndex] + holesDelta * 0.6 + 0.4);
            sessionHolesByShape[shapeIndex] += holesDelta;
        }
        if (linesCleared > 0) {
            weights[shapeIndex] = Math.max(0.4, weights[shapeIndex] - (linesCleared > 1 ? 0.5 * linesCleared : 0.2));
        }
        // формируем комментарии для панели AI Insight и сохраняем состояние в localStorage
    }

    return { loadFromStorage, resetForNewGame, selectShapeIndex, registerPlacement, getLiveHint, getSummary };
}
```

5. **Встраиваем тренер в цикл игры** — мы заменили равномерный выбор фигур на `getAdaptivePiece()`, вызывающий `aiTrainer.selectShapeIndex()`. В момент фиксации фигуры собираем метрики до и после установки, затем передаём их в `registerPlacement` и обновляем текст панели: `updateAiInsight(aiTrainer.getLiveHint());`. При запуске игры вызываем `aiTrainer.resetForNewGame(board)`, а при поражении показываем отчёт `aiTrainer.getSummary(finalMetrics)`. Состояние тренера автоматически сохраняется в `localStorage`, поэтому ИИ продолжает обучение между запусками.

Благодаря подсказкам Copilot мы добавили адаптивный интеллект, не затронув базовую механику. Теперь игра подстраивается под стиль игрока и объясняет свои решения на понятном языке.

## Дальнейшее развитие проекта

Наш проект открыт для дальнейших улучшений. Вот несколько идей для будущего развития:

1. **Добавление мобильной поддержки** — реализация сенсорного управления для игры на мобильных устройствах
2. **Сохранение прогресса** — использование localStorage для сохранения лучших результатов
3. **Улучшение графики** — добавление тем оформления и более продвинутых визуальных эффектов
4. **Звуковые эффекты** — добавление музыки и звуков для более полного игрового опыта
5. **Режим мультиплеера** — возможность соревноваться с другими игроками

## Заключение

Наш проект демонстрирует эффективность сотрудничества начинающего программиста и искусственного интеллекта. Microsoft Copilot выступил в роли наставника, который объяснял сложные концепции, предлагал оптимальные решения и помогал преодолевать технические трудности.

Такой подход к обучению программированию имеет ряд преимуществ:
- Практическое применение знаний на реальном проекте
- Немедленная обратная связь и исправление ошибок
- Изучение лучших практик и паттернов программирования
- Возможность реализовать проект, который иначе мог бы показаться слишком сложным

Этот учебник — лишь начало вашего пути в мир разработки игр и программирования. С Microsoft Copilot в качестве вашего помощника, вы сможете реализовать множество интересных проектов и постепенно развить свои навыки до профессионального уровня.

Удачи в ваших будущих проектах!